"""
basic_consumer_mahi.py

Read a log file as it is being written and alert on specific patterns. 
"""

#####################################
# Import Modules
#####################################

# Import packages from Python Standard Library
import os
import time

# Import external packages (must be installed in .venv first)
from dotenv import load_dotenv

# Import functions from local modules
from utils.utils_logger import logger, get_log_file_path

#####################################
# Load Environment Variables
#####################################

# Load environment variables from .env
load_dotenv()

#####################################
# Define Getter Functions for .env Variables
#####################################

# Function to fetch the message interval from environment or use a default value
def get_message_interval() -> int:
    """
    Fetch message interval from environment or use a default value.
    """
    return_value: str = os.getenv("MESSAGE_INTERVAL_SECONDS", "5")
    interval: int = int(return_value)
    logger.info(f"Messages will be checked every {interval} seconds.")
    return interval

# Fetch the alert message patterns from the environment or use default ones
ALERT_PATTERNS = [
    os.getenv("ALERT_PATTERN_1", "I just loved a movie! It was amazing."),
    os.getenv("ALERT_PATTERN_2", "I just tried an app! It was very weird.")
]

#####################################
# Define a function to process a single message
#####################################

def process_message(log_file) -> None:
    """
    Read a log file and process each message, alerting on specific patterns.

    Args:
        log_file (str): The path to the log file to read.
    """
    with open(log_file, "r") as file:
        # Move to the end of the file
        file.seek(0, os.SEEK_END)
        print("Consumer is ready and waiting for a new log message...")

        # Use while True loop so the consumer keeps running forever
        while True:
            # Read the next line of the file
            line = file.readline()

            # If the line is empty, wait for a new log entry
            if not line:
                # Wait a second for a new log entry
                delay_seconds = get_message_interval()
                time.sleep(delay_seconds)
                # Keep checking for new log entries
                continue

            # We got a new log entry!
            # Remove any leading/trailing white space and log the message
            message = line.strip()
            print(f"Consumed log message: {message}")

            # Implement real-time analytics: Alert on specific patterns
            for pattern in ALERT_PATTERNS:
                if pattern in message:
                    print(f"ALERT: Special message found! \n{message}")
                    logger.warning(f"ALERT: Special message found! \n{message}")

#####################################
# Define main function for this script.
#####################################

def main() -> None:
    """Main entry point."""

    logger.info("START...")

    # Call the function to get the path to the log file being generated by the producer
    log_file_path = get_log_file_path()
    logger.info(f"Reading file located at {log_file_path}.")

    try:
        # Try to call the process_message function with the log file path
        process_message(log_file_path)

    except KeyboardInterrupt:
        print("User stopped the process.")

    logger.info("END.....")

#####################################
# Conditional Execution
#####################################

# If this file is the one being executed, call the main() function
if __name__ == "__main__":
    main()
